package commands

import (
	"crypto/sha256"
	"fmt"
	"io"

	"github.com/ethereum/go-ethereum/crypto"
	"github.com/moltbunker/moltbunker/internal/identity"
	"golang.org/x/crypto/hkdf"
)

const (
	kekSize = 32

	// masterSignMessage is the deterministic message signed to derive the master KEK.
	// Using RFC 6979 deterministic signing ensures the same wallet always produces the same KEK.
	masterSignMessage = "moltbunker:exec-master:v1"

	hkdfMasterSalt  = "moltbunker-exec"
	hkdfMasterInfo  = "master-kek"
	hkdfExecInfo    = "exec-key"
	hkdfSessionInfo = "session-key"
)

// deriveMasterKEK derives the master Key Encryption Key from a wallet.
//
// Key hierarchy step 1:
//
//	sig = wallet.Sign(EIP191Hash("moltbunker:exec-master:v1"))   // RFC 6979 deterministic
//	master_kek = HKDF-SHA256(sig, salt="moltbunker-exec", info="master-kek")
//
// The master_kek is deterministic: same wallet always produces the same key.
// It never leaves the CLI/browser memory.
func deriveMasterKEK(wallet *identity.WalletManager, password string) ([]byte, error) {
	// EIP-191 personal_sign: hash("\x19Ethereum Signed Message:\n" + len + message)
	msg := []byte(masterSignMessage)
	prefixed := fmt.Appendf(nil, "\x19Ethereum Signed Message:\n%d%s", len(msg), msg)
	hash := crypto.Keccak256(prefixed)

	// Sign the hash with the wallet's private key (RFC 6979 deterministic)
	sig, err := wallet.SignHash(hash, password)
	if err != nil {
		return nil, fmt.Errorf("sign master message: %w", err)
	}

	// Derive master KEK via HKDF-SHA256
	return hkdfDerive(sig, []byte(hkdfMasterSalt), []byte(hkdfMasterInfo), kekSize)
}

// deriveExecKey derives a per-container exec_key from the master KEK.
//
// Key hierarchy step 2:
//
//	exec_key = HKDF-SHA256(master_kek, salt=deploy_nonce, info="exec-key")
//
// deploy_nonce is a 32-byte random value generated at deployment time.
// The exec_key is injected into the container at /run/secrets/exec_key.
func deriveExecKey(masterKEK, deployNonce []byte) ([]byte, error) {
	if len(masterKEK) != kekSize {
		return nil, fmt.Errorf("master_kek must be %d bytes, got %d", kekSize, len(masterKEK))
	}
	return hkdfDerive(masterKEK, deployNonce, []byte(hkdfExecInfo), kekSize)
}

// deriveSessionKey derives a per-session AES-256-GCM key from the exec_key.
//
// Key hierarchy step 3:
//
//	session_key = HKDF-SHA256(exec_key, salt=session_nonce, info="session-key")
//
// session_nonce is generated by the CLI/browser at the start of each exec session.
// Both sides (CLI + exec-agent) derive the same session_key independently.
func deriveSessionKey(execKey, sessionNonce []byte) ([]byte, error) {
	if len(execKey) != kekSize {
		return nil, fmt.Errorf("exec_key must be %d bytes, got %d", kekSize, len(execKey))
	}
	return hkdfDerive(execKey, sessionNonce, []byte(hkdfSessionInfo), kekSize)
}

// hkdfDerive is a helper that derives a key using HKDF-SHA256.
func hkdfDerive(secret, salt, info []byte, keyLen int) ([]byte, error) {
	r := hkdf.New(sha256.New, secret, salt, info)
	key := make([]byte, keyLen)
	if _, err := io.ReadFull(r, key); err != nil {
		return nil, fmt.Errorf("HKDF derive: %w", err)
	}
	return key, nil
}
